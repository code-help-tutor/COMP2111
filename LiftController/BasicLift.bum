<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<org.eventb.core.machineFile org.eventb.core.comment="This machine models the basic lift movements,&#10;and establishes the basic lift constraints.&#10;The behaviour is non-deterministic:&#10;there is no attempt to express any sort of lift control or scheduling.&#10;A discpline of lift direction is established:&#10;* level 0: direction is UP&#10;* level MAXFLOOR: direction is DOWN&#10;* other floors: either direction is valid&#10;A lift at any time has one of the following statuses:&#10;IDLE: not currently an active lift&#10;STOPPED: not moving&#10;MOVING: moving between floors&#10;The status of a lift must be STOPPED before it becomes IDLE;&#10;and must be STOPPED before it becomes MOVING&#10;There are no doors. " org.eventb.core.configuration="org.eventb.core.fwd" org.eventb.texttools.text_lastmodified="1274767732610" org.eventb.texttools.text_representation="machine BasicLift sees Lift_ctx&#13;&#13;variables liftposition liftstatus liftdirection&#13;&#13;invariants&#13;  @inv1 liftposition ∈ LIFT → FLOOR&#13;  theorem @thm1 finite(liftposition)&#13;  @inv2 liftstatus ∈ LIFT → STATUS&#13;  theorem @thm2 finite(liftstatus)&#13;  @inv3 liftdirection ∈ LIFT → DIRECTION&#13;  theorem @thm3 finite(liftdirection)&#13;  @inv4 ∀l·l ∈ LIFT ∧ liftposition(l) = 0&#13;        ⇒&#13;        liftdirection(l) = UP&#13;  @inv5 ∀l·l ∈ LIFT ∧ liftposition(l) = MAXFLOOR&#13;        ⇒&#13;        liftdirection(l) = DOWN&#13;  theorem @thm4 ∀l·l ∈ LIFT ∧ liftdirection(l) = DOWN&#13;                ⇒&#13;                liftposition(l) ≠ 0&#13;  theorem @thm5 ∀l·l ∈ LIFT ∧ liftdirection(l) = UP&#13;                ⇒&#13;                liftposition(l) ≠ MAXFLOOR&#13;  theorem @thm6 ∀l·l ∈ LIFT ∧ liftdirection(l) = UP&#13;                ⇒&#13;                liftposition(l)+1 ≤ MAXFLOOR&#13;&#13;events&#13;  event INITIALISATION&#13;  /* This machine models the basic lift movements,&#13;     and establishes the basic lift constraints.&#13;     The behaviour is non-deterministic:&#13;     there is no attempt to express any sort of lift control or scheduling.&#13;     A discpline of lift direction is established:&#13;     level 0: direction is UP&#13;     level MAXFLOOR: direction is DOWN&#13;     other floors: either direction is valid&#13;     There are no doors. */&#13;    then&#13;      @act1 liftposition ≔ LIFT×{0}&#13;      @act2 liftdirection ≔ LIFT×{UP}&#13;      @act3 liftstatus ≔ LIFT×{IDLE}&#13;  end&#13;&#13;  event IdleLift // Idle lifts cannot move&#13;    any lift&#13;    where&#13;      @grd1 liftstatus(lift) = STOPPED&#13;    then&#13;      @act1 liftstatus(lift) ≔ IDLE&#13;  end&#13;&#13;  event ActiveateLift // Ready an Idle lift to enable moving&#13;    any lift&#13;    where&#13;      @grd1 liftstatus(lift) = IDLE&#13;    then&#13;      @act1 liftstatus :∣ liftstatus' ∈ LIFT → STATUS&#13;            ∧ ((liftstatus' = liftstatus  {lift ↦ STOPPED})&#13;               ∨&#13;              (liftstatus' = liftstatus  {lift ↦ WAITING}))&#13;  end&#13;&#13;  event StartLift // Models the starting of a STOPPED lift, maintaining of previous direction&#13;    any lift&#13;    where&#13;      @grd1 liftstatus(lift) = STOPPED&#13;    then&#13;      @act1 liftstatus(lift) ≔ MOVING&#13;  end&#13;&#13;  event ChangeDir // Models the changing of direction of a STOPPED lift&#13;    any lift&#13;    where&#13;      @grd1 liftstatus(lift) = STOPPED&#13;      @grd2 liftposition(lift) ≠ 0&#13;      @grd3 liftposition(lift) ≠ MAXFLOOR&#13;    then&#13;      @act1 liftdirection(lift) ≔ CHANGE(liftdirection(lift))&#13;  end&#13;&#13;  event MoveUp&#13;  /* Models a lift moving up to the next floor&#13;     Either stopping or continuring to move */&#13;    any lift&#13;    where&#13;      @grd1 liftstatus(lift) = MOVING&#13;      @grd2 liftdirection(lift) = UP&#13;    then&#13;      @act1 liftposition(lift) ≔ liftposition(lift) + 1&#13;      @act2 liftdirection :∣ liftdirection' ∈ LIFT → DIRECTION&#13;            ∧ (liftposition(lift) + 1 = MAXFLOOR&#13;            ⇒&#13;            liftdirection' = liftdirection  {lift ↦ DOWN})&#13;            ∧ (liftposition(lift) + 1 ≠ MAXFLOOR&#13;            ⇒&#13;            liftdirection' = liftdirection)&#13;      @act3 liftstatus :∣ liftstatus' ∈ LIFT → STATUS ∧&#13;            ((liftstatus' = liftstatus  {lift ↦ MOVING})&#13;            ∨&#13;            (liftstatus' = liftstatus  {lift ↦ WAITING})&#13;            ∨&#13;            (liftstatus' = liftstatus  {lift ↦ STOPPED}))&#13;  end&#13;&#13;  event MoveDown&#13;  /* Models a lift moving down to the next floor&#13;     Either stopping or continuring to move */&#13;    any lift&#13;    where&#13;      @grd1 liftstatus(lift) = MOVING&#13;      @grd2 liftdirection(lift) = DOWN&#13;    then&#13;      @act1 liftposition(lift) ≔ liftposition(lift) − 1&#13;      @act2 liftdirection :∣ liftdirection' ∈ LIFT → DIRECTION&#13;            ∧ (liftposition(lift) = 1&#13;            ⇒&#13;            liftdirection' = liftdirection  {lift ↦ UP})&#13;            ∧ (liftposition(lift) ≠ 1&#13;            ⇒&#13;            liftdirection' = liftdirection)&#13;      @act3 liftstatus :∣ liftstatus' ∈ LIFT → STATUS ∧&#13;            ((liftstatus' = liftstatus  {lift ↦ MOVING})&#13;            ∨&#13;            (liftstatus' = liftstatus  {lift ↦ WAITING})&#13;            ∨&#13;            (liftstatus' = liftstatus  {lift ↦ STOPPED}))&#13;  end&#13;end&#13;" version="5">
<org.eventb.core.seesContext name="__mPIAGfDEd-6O_y_i4NrrQ" org.eventb.core.target="Lift_ctx"/>
<org.eventb.core.variable name="set1" org.eventb.core.identifier="liftposition"/>
<org.eventb.core.variable name="set2" org.eventb.core.comment="" org.eventb.core.identifier="liftstatus"/>
<org.eventb.core.variable name="set3" org.eventb.core.identifier="liftdirection"/>
<org.eventb.core.invariant name="inv1" org.eventb.core.label="inv1" org.eventb.core.predicate="liftposition ∈ LIFT → FLOOR"/>
<org.eventb.core.invariant name="inv2" org.eventb.core.label="thm1" org.eventb.core.predicate="finite(liftposition)" org.eventb.core.theorem="true"/>
<org.eventb.core.invariant name="inv3" org.eventb.core.label="inv2" org.eventb.core.predicate="liftstatus ∈ LIFT → STATUS"/>
<org.eventb.core.invariant name="inv4" org.eventb.core.label="thm2" org.eventb.core.predicate="finite(liftstatus)" org.eventb.core.theorem="true"/>
<org.eventb.core.invariant name="inv5" org.eventb.core.label="inv3" org.eventb.core.predicate="liftdirection ∈ LIFT → DIRECTION"/>
<org.eventb.core.invariant name="inv6" org.eventb.core.label="thm3" org.eventb.core.predicate="finite(liftdirection)" org.eventb.core.theorem="true"/>
<org.eventb.core.invariant name="inv7" org.eventb.core.label="inv4" org.eventb.core.predicate="∀l·l ∈ LIFT ∧ liftposition(l) = 0&#10;⇒&#13;liftdirection(l) = UP"/>
<org.eventb.core.invariant name="inv8" org.eventb.core.label="inv5" org.eventb.core.predicate="∀l·l ∈ LIFT ∧ liftposition(l) = MAXFLOOR&#10;⇒ liftdirection(l) = DOWN"/>
<org.eventb.core.invariant name="inv9" org.eventb.core.label="thm4" org.eventb.core.predicate="∀l·l ∈ LIFT ∧ liftdirection(l) = DOWN&#10;⇒ liftposition(l) ≠ 0" org.eventb.core.theorem="true"/>
<org.eventb.core.invariant name="inv10" org.eventb.core.label="thm5" org.eventb.core.predicate="∀l·l ∈ LIFT ∧ liftdirection(l) = UP&#10;⇒ liftposition(l) ≠ MAXFLOOR" org.eventb.core.theorem="true"/>
<org.eventb.core.invariant name="inv11" org.eventb.core.label="thm6" org.eventb.core.predicate="∀l·l ∈ LIFT ∧ liftdirection(l) = UP&#10;⇒ liftposition(l)+1 ≤ MAXFLOOR" org.eventb.core.theorem="true"/>
<org.eventb.core.event name="evt1" org.eventb.core.comment="" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="INITIALISATION">
<org.eventb.core.action name="internal_element5" org.eventb.core.assignment="liftposition ≔ LIFT×{0}" org.eventb.core.label="act1"/>
<org.eventb.core.action name="internal_element6" org.eventb.core.assignment="liftdirection ≔ LIFT×{UP}" org.eventb.core.label="act2"/>
<org.eventb.core.action name="internal_element7" org.eventb.core.assignment="liftstatus ≔ LIFT×{IDLE}" org.eventb.core.label="act3"/>
</org.eventb.core.event>
<org.eventb.core.event name="evt5" org.eventb.core.comment="Idle lifts cannot move" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="IdleLift">
<org.eventb.core.parameter name="internal_prm1" org.eventb.core.identifier="lift"/>
<org.eventb.core.guard name="internal_grd2" org.eventb.core.label="grd1" org.eventb.core.predicate="liftstatus(lift) = STOPPED"/>
<org.eventb.core.action name="internal_act1" org.eventb.core.assignment="liftstatus(lift) ≔ IDLE" org.eventb.core.label="act1"/>
</org.eventb.core.event>
<org.eventb.core.event name="evt6" org.eventb.core.comment="Ready an Idle lift to enable moving" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="ActivateLift">
<org.eventb.core.parameter name="element1" org.eventb.core.identifier="lift"/>
<org.eventb.core.guard name="element2" org.eventb.core.label="grd1" org.eventb.core.predicate="liftstatus(lift) = IDLE"/>
<org.eventb.core.action name="element1" org.eventb.core.assignment="liftstatus(lift) ≔ STOPPED" org.eventb.core.label="act1"/>
</org.eventb.core.event>
<org.eventb.core.event name="evt7" org.eventb.core.comment="Models the starting of a STOPPED lift, &#10;maintaining previous direction" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="StartLift">
<org.eventb.core.parameter name="internal_element1" org.eventb.core.identifier="lift"/>
<org.eventb.core.guard name="internal_element1" org.eventb.core.comment="" org.eventb.core.label="grd1" org.eventb.core.predicate="liftstatus(lift) = STOPPED"/>
<org.eventb.core.action name="internal_element1" org.eventb.core.assignment="liftstatus(lift) ≔ MOVING" org.eventb.core.label="act1"/>
</org.eventb.core.event>
<org.eventb.core.event name="evt8" org.eventb.core.comment="Models the changing of direction of a STOPPED lift" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="ChangeDir">
<org.eventb.core.parameter name="internal_element1" org.eventb.core.identifier="lift"/>
<org.eventb.core.guard name="internal_element1" org.eventb.core.label="grd1" org.eventb.core.predicate="liftstatus(lift) = STOPPED"/>
<org.eventb.core.guard name="internal_element3" org.eventb.core.label="grd2" org.eventb.core.predicate="liftposition(lift) ≠ 0"/>
<org.eventb.core.guard name="internal_element4" org.eventb.core.label="grd3" org.eventb.core.predicate="liftposition(lift) ≠ MAXFLOOR"/>
<org.eventb.core.action name="internal_element1" org.eventb.core.assignment="liftdirection(lift) ≔ CHANGE(liftdirection(lift))" org.eventb.core.label="act1"/>
</org.eventb.core.event>
<org.eventb.core.event name="evt10" org.eventb.core.comment="Models a lift moving up to the next floor&#10;where its status is either MOVING or STOPPED" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="MoveUp">
<org.eventb.core.parameter name="internal_element1" org.eventb.core.identifier="lift"/>
<org.eventb.core.guard name="internal_element2" org.eventb.core.label="grd1" org.eventb.core.predicate="liftstatus(lift) = MOVING"/>
<org.eventb.core.guard name="internal_element3" org.eventb.core.label="grd2" org.eventb.core.predicate="liftdirection(lift) = UP"/>
<org.eventb.core.action name="internal_element1" org.eventb.core.assignment="liftposition(lift) ≔ liftposition(lift) + 1" org.eventb.core.comment="" org.eventb.core.label="act1"/>
<org.eventb.core.action name="internal_element2" org.eventb.core.assignment="liftdirection :∣ liftdirection' ∈ LIFT → DIRECTION&#10;∧ (liftposition(lift) + 1 = MAXFLOOR&#10;⇒&#10;liftdirection' = liftdirection  {lift ↦ DOWN})&#10;∧ (liftposition(lift) + 1 ≠ MAXFLOOR&#10;⇒&#10;liftdirection' = liftdirection)" org.eventb.core.label="act2"/>
<org.eventb.core.action name="internal_element4" org.eventb.core.assignment="liftstatus :∣ liftstatus' ∈ LIFT → STATUS ∧&#10;((liftstatus' = liftstatus  {lift ↦ MOVING})&#10;∨&#10;(liftstatus' = liftstatus  {lift ↦ STOPPED}))" org.eventb.core.label="act3"/>
</org.eventb.core.event>
<org.eventb.core.event name="evt12" org.eventb.core.comment="Models a lift moving down to the next floor&#10;where its status is either MOVING or STOPPED" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="MoveDown">
<org.eventb.core.parameter name="internal_element1" org.eventb.core.identifier="lift"/>
<org.eventb.core.guard name="internal_element2" org.eventb.core.comment="" org.eventb.core.label="grd1" org.eventb.core.predicate="liftstatus(lift) = MOVING"/>
<org.eventb.core.guard name="internal_element3" org.eventb.core.label="grd2" org.eventb.core.predicate="liftdirection(lift) = DOWN"/>
<org.eventb.core.action name="internal_element1" org.eventb.core.assignment="liftposition(lift) ≔ liftposition(lift) − 1" org.eventb.core.label="act1"/>
<org.eventb.core.action name="internal_element2" org.eventb.core.assignment="liftdirection :∣ liftdirection' ∈ LIFT → DIRECTION&#10;∧ (liftposition(lift) = 1&#10;⇒&#10;liftdirection' = liftdirection  {lift ↦ UP})&#10;∧ (liftposition(lift) ≠ 1&#10;⇒&#10;liftdirection' = liftdirection)" org.eventb.core.label="act2"/>
<org.eventb.core.action name="internal_element4" org.eventb.core.assignment="liftstatus :∣ liftstatus' ∈ LIFT → STATUS ∧&#10;((liftstatus' = liftstatus  {lift ↦ MOVING})&#10;∨&#10;(liftstatus' = liftstatus  {lift ↦ STOPPED}))" org.eventb.core.label="act3"/>
</org.eventb.core.event>
</org.eventb.core.machineFile>
